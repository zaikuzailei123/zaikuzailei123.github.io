---
layout: post
title: 2020-11-25-文件系统
date: 2020-11-25
categories: blog
tags: [linux,操作系统]
description: 文件系统  

html:
  embed_local_images: true
  embed_svg: false
  offline: false
  toc: undefined 
    print_background: false
export_on_save:
  html: true
---

# 日志文件系统

## 数据不一致状态

在正常情况下，新增文件（修改metadata）操作可以顺利完成，但是如果遇见突发情况，写入的数据仅有inode及data block，最后一个同步工作没有做完，则就会发生不一致情况。

## 早期Ext2文件系统

如果发生这个问题，那么系统重新启动的时候就会通过Super block当中的valid bit是否有挂在以及文件系统的state clean与否等状态判断是否强制进行数据一致性检查，若有需要检查时则以e2fsck这支程序来进行。（也就是针对meta data数据与实际存放数据区进行对比。）

## 日志文件系统  

日志文件系统（英语：Journaling file system）是一种文件系统。在发生变化时，它先把相关的信息写入一个被称为日志的区域，然后再把变化写入主文件系统。在文件系统发生故障（如内核崩溃或突然停电）时，日志文件系统更容易保持一致性，并且可以较快恢复。  

对文件系统进行修改时，需要进行很多操作。这些操作可能中途被打断，也就是说，这些操作不是“不可中断”(atomic)的。如果操作被打断，就可能造成文件系统出现不一致的状态。

例如：删除文件时，先要从目录树中移除文件的标示，然后收回文件占用的空间。如果在这两步之间操作被打断，文件占用的空间就无法收回。文件系统认为它是被占用的，但实际上目录树中已经找不到使用它的文件了。 

在非日志文件系统中，要检查并修复类似的错误就必须对整个文件系统的数据结构进行检查。一般在挂载文件系统前，操作系统会检查它上次是否被成功卸载，如果没有，就会对其进行检查。如果文件系统很大或者I/O带宽有限，这个操作可能会花费很长时间。

为了避免这样的问题，日志文件系统分配了一个称为日志（journal）的区域来提前记录要对文件系统做的更改。在崩溃后，只要读取日志重新执行未完成的操作，文件系统就可以恢复一致。这种恢复是原子的，因为只存在几种情况：

* **不需要重新执行：这个事务被标记为已经完成**  
* **成功重新执行：根据日志，这个事务被重新执行**  
* **无法重新执行：这个事务会被撤销，就如同这个事务从来没有发生过**  
* **日志本身不完整：事务还没有被完全写入日志，它会被简单忽略**

### 日志的三个级别  

#### 回写  
在回写模式中，**只有元数据被记录到日志中，数据会被直接写入主文件系统。**这种模式能提供较好的性能，不过有较大的风险。例如：在增大文件时，数据还未写入就发生崩溃，那么文件系统恢复后，文件后面就可能出现垃圾数据。  

#### 顺序  

在顺序模式中，**只有元数据被记录到日志中，但在日志被标记为提交前，数据会被写入文件系统。**在这种模式下，如果在增大文件时，数据还未写入就发生崩溃，那么在恢复时这个事务会被简单的撤销，文件保持原来的状态。

#### 数据  
在数据模式中，元数据和文件内容都先被写入日志中，然后在提交到主文件系统。这提高了安全性，但损失性能，因为所有数据要写入两次[1]。在这种模式下，如果在增大文件时，发生崩溃，那么可能有两种情况：  

* 日志完整：这时事务会被重新执行，修改会被提交到主文件系统  
* 日志不完整：这时主文件系统还未被修改，只需要简单放弃这个事务  

### 常见的日志文件系统  
1. JFS：IBM的 Journaled File System, 最早的日志文件系统。  
2. Ext4/Ext3文件系统：由Ext2文件系统演化而成的日志文件系统，广泛用于Linux系统。  
3. XFS文件系统：广泛用于Linux系统，取代了Ext4。
ReiserFS：用B+树作为数据结构的日志文件系统，在处理小文件时有较好的性能。  
4. Btrfs：用B树作为数据结构，被认为是下一代Linux文件系统。  
5. NTFS：微软的NTFS也是日志文件系统，也是Windows下最常用的文件系统。  
6. HFS+：苹果公司发展的OS X操作系统下主要使用的文件系统。  


# 虚拟文件系统  

Linux 不仅仅支持Ext2/Ext3文件系统，还支持了许多其他的文件系统，查看支持的文件系统命令：  

```shell
ls -l /lib/modules/$(uname -r) /kernel/fs
```

查看系统已加载到内存的文件系统：  
```shell
cat /proc/filesystems
```

### 虚拟文件系统简介  

虚拟文件系统（Virtual File System，简称VFS）是Linux内核的子系统之一，它为用户程序提供文件和文件系统操作的统一接口，屏蔽不同文件系统的差异和操作细节。借助VFS可以直接使用open()、read()、write()这样的系统调用操作文件，而无须考虑具体的文件系统和实际的存储介质。

举个例子，Linux用户程序可以通过read() 来读取ext3、NFS、XFS等文件系统的文件，也可以读取存储在SSD、HDD等不同存储介质的文件，无须考虑不同文件系统或者不同存储介质的差异。

通过VFS系统，Linux提供了通用的系统调用，可以跨越不同文件系统和介质之间执行，极大简化了用户访问不同文件系统的过程。另一方面，新的文件系统、新类型的存储介质，可以无须编译的情况下，动态加载到Linux中。

"一切皆文件"是Linux的基本哲学之一，不仅是普通的文件，包括目录、字符设备、块设备、套接字等，都可以以文件的方式被对待。实现这一行为的基础，正是Linux的虚拟文件系统机制。  

### 虚拟文件系统原理  

VFS之所以能够衔接各种各样的文件系统，是因为它抽象了一个通用的文件系统模型，定义了通用文件系统都支持的、概念上的接口。新的文件系统只要支持并实现这些接口，并注册到Linux内核中，即可安装和使用。

举个例子，比如Linux写一个文件：
```C
int ret = write(fd, buf, len);
```

调用了write()系统调用，它的过程简要如下：

* 首先，勾起VFS通用系统调用sys_write()处理。
* 接着，sys_write()根据fd找到所在的文件系统提供的写操作函数，比如op_write()。
* 最后，调用op_write()实际的把数据写入到文件中。
操作示意图如下：  
![图片](/images/20201125-1.jpg)  

## 虚拟文件系统组成部分  

Linux为了实现这种VFS系统，采用面向对象的设计思路，主要抽象了四种对象类型：

* 超级块对象：代表一个已安装的文件系统。  
* 索引节点对象：代表具体的文件。  
* 目录项对象：代表一个目录项，是文件路径的一个组成部分。  
* 文件对象：代表进程打开的文件。  

每个对象都包含一组操作方法，用于操作相应的文件系统。

备注：Linux将目录当做文件对象来处理，是另一种形式的文件，它里面包含了一个或多个目录项。而目录项是单独抽象的对象，主要包括文件名和索引节点号。因为目录是可以层层嵌套，以形成文件路径，而路径中的每一部分，其实就是目录项。

接下来介绍一下各个对象的作用以及相关操作。

### 超级块  

超级块用于存储文件系统的元信息，由super_block结构体表示，定义在<linux/fs.h>中，元信息里面包含文件系统的基本属性信息，比如有：

* 索引节点信息  
* 挂载的标志  
* 操作方法 s_op  
* 安装权限  
* 文件系统类型、大小、区块数  

其中操作方法 s_op 对每个文件系统来说，是非常重要的，它指向该超级块的操作函数表，包含一系列操作方法的实现，这些方法有：

* 分配inode  
* 销毁inode  
* 读、写inode  
* 文件同步  
* 等等  

当VFS需要对超级块进行操作时，首先要在超级块的操作方法 s_op 中，找到对应的操作方法后再执行。比如文件系统要写自己的超级块：
```C
superblock->s_op->write_supper(sb);
```

创建文件系统时，其实就是往存储介质的特定位置，写入超级块信息；而卸载文件系统时，由VFS调用释放超级块。

Linux支持众多不同的文件系统，file_system_type结构体用于描述每种文件系统的功能和行为，包括：

* 名称、类型等
* 超级块对象链表

当向内核注册新的文件系统时，其实是将file_system_type对象实例化，然后加入到Linux的根文件系统的目录树结构上。  

### 索引  

索引节点对象包含Linux内核在操作文件、目录时，所需要的全部信息，这些信息由inode结构体来描述，定义在<linux/fs.h>中，主要包含：

* 超级块相关信息  
* 目录相关信息  
* 文件大小、访问时间、权限相关信息  
* 引用计数  

一个索引节点inode代表文件系统中的一个文件，只有当文件被访问时，才在内存中创建索引节点。与超级块类似的是，索引节点对象也提供了许多操作接口，供VFS系统使用，这些接口包括：

create(): 创建新的索引节点（创建新的文件）
link(): 创建硬链接
symlink(): 创建符号链接。
mkdir(): 创建新的目录。
等等，我们常规的文件操作，都能在索引节点中找到相应的操作接口。

### 目录项  
前面提到VFS把目录当做文件对待，比如/usr/bin/vim，usr、bin和vim都是文件，不过vim是一个普通文件，usr和bin都是目录文件，都是由索引节点对象标识。

由于VFS会经常的执行目录相关的操作，比如切换到某个目录、路径名的查找等等，为了提高这个过程的效率，VFS引入了目录项的概念。一个路径的组成部分，不管是目录还是普通文件，都是一个目录项对象。/、usr、bin、vim都对应一个目录项对象。**不过目录项对象没有对应的磁盘数据结构，是VFS在遍历路径的过程中，将它们逐个解析成目录项对象。**

目录项由dentry结构体标识，定义在<linux/dcache.h>中，主要包含：

* 父目录项对象地址  
* 子目录项链表  
* 目录关联的索引节点对象  
* 目录项操作指针  

目录项有三种状态：

* 被使用：该目录项指向一个有效的索引节点，并有一个或多个使用者，不能被丢弃。  
* 未被使用：也对应一个有效的索引节点，但VFS还未使用，被保留在缓存中。如果要回收内存的话，可以撤销未使用的目录项。  
* 负状态：没有对应有效的索引节点，因为索引节点被删除了，或者路径不正确，但是目录项仍被保留了。  

将整个文件系统的目录结构解析成目录项，是一件费力的工作，为了节省VFS操作目录项的成本，内核会将目录项缓存起来。  

### 文件  

文件对象是进程打开的文件在内存中的实例。Linux用户程序可以通过open()系统调用来打开一个文件，通过close()系统调用来关闭一个文件。由于多个进程可以同时打开和操作同一个文件，所以同一个文件，在内存中也存在多个对应的文件对象，但对应的索引节点和目录项是唯一的。

文件对象由file结构体表示，定义在<linux/fs.h>中，主要包含：

* 文件操作方法
* 文件对象的引用计数
* 文件指针的偏移
* 打开文件时的读写标识

类似于目录项，文件对象也没有实际的磁盘数据，只有当进程打开文件时，才会在内存中产生一个文件对象。

每个进程都有自己打开的一组文件，由file_struct结构体标识，该结构体由进程描述符中的files字段指向。主要包括：

* fdt
* fd_array[NR_OPEN_DEFAULT]
* 引用计数  

fd_array数组指针指向已打开的文件对象，如果打开的文件对象个数 > NR_OPEN_DEFAULT，内核会分配一个新数组，并将 fdt 指向该数组。

除此之外，内核还为所有打开文件维持一张文件表，包括：

* 文件状态标志
* 文件偏移量


# 主设备号与次设备号 

Linux的设备管理是和文件系统紧密结合的，各种设备都以文件的形式存放在/dev目录下，称为设备文件。应用程序可以打开、关闭和读写这些设备文件，完成对设备的操作，就像操作普通的数据文件一样。为了管理这些设备，系统为设备编了号，每个设备号又分为主设备号和次设备号。**主设备号用来区分不同种类的设备，而次设备号用来区分同一类型的多个设备**。对于常用设备，Linux有约定俗成的编号，如硬盘的主设备号是3。

一个字符设备或者块设备都有一个主设备号和次设备号。**主设备号和次设备号统称为设备号。主设备号用来表示一个特定的驱动程序。次设备号用来表示使用该驱动程序的各设备**。例如一个嵌入式系统，有两个LED指示灯，LED灯需要独立的打开或者关闭。那么，可以写一个LED灯的字符设备驱动程序，可以将其主设备号注册成5号设备，次设备号分别为1和2。这里，次设备号就分别表示两个LED灯。  

# loop 设备  

loop 设备是一种伪设备(pseudo-device)，或者也可以说是仿真设备。它能使我们像块设备一样访问一个文件。  

对于.img之类的文件我们是否一定要把它刻录进光盘，然后才能用光驱读取呢？答案是否定的。在linux系统下，对于每一个硬件都会有一个文件与之对应，而为了读取光盘映像之类的文件我们则可以同过loop这个伪设备 。把一个文件链接到loop这个伪设备上，然后这个文件就能够用mount驱动起来，和使用其他的块设备没什么区别。  

```shell
# 创建需要挂载的目录
mkdir /mnt/test  
# 在/home下产生一个512M的大文件
dd if=/dev/zero of=/home/loopdev bs=1M count=512  
# 在大文件中创建文件系统
mkfs -t ext3 /home/loopdev  
# 借助伪设备Loop将大文件挂载到/mnt/test中
mount -o loop /home/loopdev /mnt/test  

```  

# 文件备份与恢复  
```shell
dump [-Suvj] [-level] [-f 备份文件] 待备份数据  

备份level： level=0是全量备份，1是基于0的差异备份，2是基于1的差异备份，最多为9
-S：仅列出后面的待备份数据要多少磁盘空间才能允许备份
-u：将这次的dump的时间记录到/etc/dumpdateS文件中
-v：将dump的文件过程显示出来
-j：加入bzip2的支持，将数据进行压缩，默认bzip2压缩等级为2  
-f：类似tar，后面接产生的文件，也可接设备名，例如/dev/st0  
-W： 列出在/etc/fstab里面具有dump设置的分取是否备份过
```

例如：

```shell
df -h 查看需要备份的文件系统设备名称
# 查看需要备份的空间
dump -S /dev/hdc1   

# 开始备份（全量）
dump -0u -f /root/boot.dump  /boot

# 查看任何被dump过的文件系统
dump -W  

# 新建一个差异备份
dump -1u -f /boor/boot.dump /boot  

# 备份非文件系统  
dump -0j -f /root/etc.dump.bz2 /etc
```

**根据dump进行恢复：restore**

```shell
# 查看dump文件
restore -t -f  /root/boot.dump  

# 比较差异
首先进入到原来备份的文件系统中
cd /boot
# 查看差异
restore -C -f /root/boot/dump

# 开始还原操作
务必进入到待还原的文件系统中
restore -r -f /root/boot.dump

# 另一种选择，使用交互式还原，可还原部分文件
restore -i -f /root/etc.dump

```

其他常见备份工具：

```shell

dd if="input file | device file name" of="input file | device file name" bs="blocksize" count="count"

cpio -ovcB < [file|device]   (备份)
cpio -ivcdu < [file|device]  (还原)
cpio -ivct < [file|device]   (查看)

一般结合find：
find / | cpio -ocvB > /dev/st0

```

# 磁盘相关命令  

```shell
df: 查看当前挂载的设备及硬盘使用量（按照实际使用量而不是所占用的block）

# -b：列出坏道的部分，查看卷标
dumpe2fs [-bh] 设备文件名

# 链接文件
ln target link_name         # 硬链接，在某个目录下生成一个文件名和某个相同的inode的目录项

ln -s target link_name      # 创建独立文件，该文件会让其读取那个目标文件名

# 分区增加或修改
fdisk /dev/hd*

# 在分取或者文件中创建文件系统
mkfs [-t 文件系统格式] 设备文件名
mkfs -t ext3 /dev/hdc6

# 另一种格式化
mkefs [-b block大小] [-i block 大小] [-L 卷标] [-cj]设备  

# 磁盘检查工具，检查文件系统是否出错
fsck [-t 文件系统] [-ACay] 设备文件名
-A 根据 /etc/fstab的内容，将需要的设备扫描一遍（开机时会调用）
-a 自动修复，同 -y
-C 显示直方图
-f: 强制检查，如果没有该选项则不会进入没有unckean标志的磁盘

# 检查磁盘扇区有无坏轨  
-sv：列出进度
-w 使用写入的方式检查（不建议盘中有文件时用，会被覆盖）  

# 磁盘挂载  
mkdir /mnt/hdc6
mount /dev/hdc6 /mnt/hdc6
df 查看  

注/proc/filesystems: Linux已加载的文件系统
/lib/modules/$(uname -r)/kernel/fs/ : linux支持的文件系统的驱动程序，没有需要的驱动则要进行安装  

# 磁盘卸载
umount  

# 重新挂载并修改挂载属性
mount -o remount,rw,auto  /  : 重新挂载，单用户模式下因为/被挂载为只读，需要用该命令修改成读写  

# 注册设备为文件
mknod /dev/abc p 22 10  将主设备号22次设备号10的设备设置成/dev/abc，一般开机或者插入新设备的时候会自动设置  

# 修改硬盘卷标
e2label 设备名称 新label名称
例如：
dumpe2fs -h /dev/hdc6 获得卷标名
e2label /dev/hdc6 "my_test"

partprobe: 内核更新分区表（一般用在fdisk后）

# 创建交换分区(类似mkfs)
mkswap  /dev/hdc7

# 使用交换分区
swapon /dev/hdc7

# 卸载交换分区
swapoff /dev/hdc7

# 对2TB及以上的硬盘设备分区
parted
```




